## Теоретическая часть

Для решения предложенного задания его можно свести к задаче об упаковке в контейнеры.

> Задача об упаковке в контейнеры — NP-трудная комбинаторная задача. Задача заключается в упаковке объектов предопределённой формы в конечное число контейнеров предопределённой формы таким способом, чтобы число использованных контейнеров было наименьшим или количество или объём объектов (которые упаковывают) были наибольшими.

Существует множество разновидностей этой задачи (двумерная упаковка, линейная упаковка, упаковка по весу, упаковка по стоимости и т.п.), которые могут применяться в разных областях, как собственно в вопросе оптимального заполнения контейнеров, загрузки грузовиков с ограничением по весу, созданием резервных копий на съёмных носителях и т.д. Так как задача является NP-трудной, то использование точного переборного алгоритма возможно только при небольших размерностях. Обычно для решения задачи используют эвристические приближённые полиномиальные алгоритмы.

### Математическая формулировка задачи

Пусть даны множества B_j, называемые контейнерами, и множество L = {1,...,n} предметов размеров w_i, не превышающих вместимость контейнера, i принадлежит L. Надо найти разбиение множества L на минимальное число m подмножеств B_1,B_2,...,B_m такое, что сумма размеров предметов в каждом контейнере не превышает его вместимость. Решение называется оптимальным, если B минимально. Минимальное B далее обозначается OPT.

В случае нашей задачи примем высоту листа А4 за вместимость контейнера. Примем поля сверху, снизу и высоту места для разреза одинаковыми и для удобства высоту листа возьмем равной высоте обычного листа А4 минус поле сверху. За размер предмета примем высоту одного экзаменационного билета плюс поле под самим билетом (место для разреза). Будем рассматривать одномерные контейнеры.

### Варианты решения

Задачу об упаковке в контейнеры можно решить несколькими способами.

### Упаковка как задача целочисленного программирования
Задача упаковки в контейнеры может быть сформулирована как задача целочисленного программирования следующим образом:

Минимизировать B = sum(y_i), i=1,...,n

при ограничениях j=1,...,n sum(a_j\*x_ij) <= Vy_i для любого i из множества {1,...,n}

sum(x_ij) = 1 i=1,...,n для любого j из множества {1,...,n}

y_i и x_ij принадлежат множеству {0,1} для любых i и j из множества {1,...,n}

где y_i=1, если контейнер i используется и x_ij=1, если предмет j помещен в контейнер i.

### Приближенные полиномиальные алгоритмы
### Алгоритмы типа On-line
Предметы поступают в непредсказуемом порядке. Требуется упаковать их в минимальное число контейнеров. Упакованный предмет нельзя перемещать в другой контейнер. Место для предварительного хранения предметов отсутствует.

Алгоритмы NF, FF и BF являются On-line алгоритмами.

#### Алгоритм "Следующий подходящий" (NF)
В произвольном порядке упаковываем предметы по следующему правилу.

Первый предмет помещаем в первый контейнер. На k-м шаге пытаемся поместить k-й предмет в текущий контейнер. Если предмет входит, то помещаем его и переходим к следующему шагу, иначе помещаем предмет в новый контейнер.

T = O(n), П = O(1), если не считать место для исходных данных.

Теорема. NF(L) <= 2OPT(L), где L = {1,...n} - множество предметов.

#### Алгоритм "Первый подходящий" (FF)
В произвольном порядке упаковываем предметы по следующему правилу.

Первый предмет помещаем в первый контейнер. На k-м шаге находим контейнер с наименьшим номером, куда помещается k-й предмет, и помещаем его туда. Если такого контейнера нет, то берем новый пустой контейнер и помещаем предмет в него.

T = O(n^2), П = O(n).

Теорема. FF(L) <= \[17/10 OPT(L) + 1] (с округлением в большую сторону) для всех L и существуют примеры со сколь угодно большими значениями OPT, для которых FF(L) >= \[17/10 OPT(L) - 1] (с округлением в большую сторону).

#### Алгоритм "Наилучший подходящий" (BF)
В произвольном порядке упаковываем предметы по следующему правилу.

Первый предмет помещаем в первый контейнер. На k-м шаге размещаем k-й предмет. Находим частично заполненные контейнеры, где достаточно для него свободного места и выбираем среди них наиболее заполненный. Если таких нет, то берем новый пустой контейнер и помещаем k-й предмет в него.

T = O(n^2), П = O(n).

Теорема. R(BF) = R(FF) и существуют примеры со сколь угодно большими значениями OPT(L), для которых BF(L) = 4/3 FF(L) и FF(L) = 3/2 BF(L).

R(А) - асимптотическая гарантированная относительная точность алгоритма A.

#### Алгоритмы с ограниченным доступом к контейнерам
On-line алгоритм называют алгоритмом с ограниченным доступом к контейнерам, если на каждом шаге алгоритм имеет возможность помещать предметы только в один из K контейнеров (K — const). Эти контейнеры называются открытыми. Если контейнер закрыли, то он уже не открывается (например, отправляется потребителю). Прежде чем добавить пустой открытый контейнер, нужно закрыть один из K открытых контейнеров.

Правила для выбора контейнера:

1. Закрыть контейнер с наименьшим номером.

2. Закрыть самый заполненный контейнер.

Примеры алгоритмов с ограниченным доступом.

FF_1 — алгоритм FF с правилом 1;

FF_2 — алгоритм FF с правилом 2;

BF_1 — алгоритм BF с правилом 1;

BF_2 — алгоритм BF с правилом 2.

Теорема. Для любого K >= 2

1) R(FF_1) = R(FF_2) = 1.7 + 3/(10(K-1));

2) R(BF_1) = 1.7 + 3/(10K);

3) R(BF_2) = 1.7

4) Для любого алгоритма A с ограниченным доступом к контейнерам R >= 1.69103...

#### Алгорим "Первый подходящий с упорядочиванием" (FFD)

1) Сортируем предметы по невозрастанию весов w_1 >= w_2 >= ... >= w_n;

2) Применяем алгоритм FF (BF).

Теорема. FFD(L) <= 11/9 OPT(L) + 4 для всех L и существуют примеры со сколь угодно большими значениями OPT(L), для которых FFD(L) >= 11/9 OPT(L). Кроме того, R(FFD) = R (BFD) = 11/9 = 1.22.

### Асимптотически гарантированные оценки точности
![alt image](https://github.com/bindasov/examCards/blob/master/asymptotic%20accuracy%20estimates.png)

### План решения задания
В силу наилучшей асимптотической гарантированной относительной точности алгоритмов First Fit Decreasing (FFD) и Best Fit Decreasing (BFD) и их приемлемой сложности (O(nlogn)) выберем алгоритм BFD для решения представленной задачи.
